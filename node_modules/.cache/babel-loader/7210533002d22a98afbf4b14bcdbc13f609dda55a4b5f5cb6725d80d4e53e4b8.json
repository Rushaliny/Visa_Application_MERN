{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatSort = formatSort;\nconst error_1 = require(\"./error\");\n/** @internal */\nfunction prepareDirection() {\n  let direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  const value = `${direction}`.toLowerCase();\n  if (isMeta(direction)) return direction;\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new error_1.MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);\n  }\n}\n/** @internal */\nfunction isMeta(t) {\n  return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';\n}\n/** @internal */\nfunction isPair(t) {\n  if (Array.isArray(t) && t.length === 2) {\n    try {\n      prepareDirection(t[1]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  return false;\n}\nfunction isDeep(t) {\n  return Array.isArray(t) && Array.isArray(t[0]);\n}\nfunction isMap(t) {\n  return t instanceof Map && t.size > 0;\n}\nfunction isReadonlyArray(value) {\n  return Array.isArray(value);\n}\n/** @internal */\nfunction pairToMap(v) {\n  return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);\n}\n/** @internal */\nfunction deepToMap(t) {\n  const sortEntries = t.map(_ref => {\n    let [k, v] = _ref;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\nfunction stringsToMap(t) {\n  const sortEntries = t.map(key => [`${key}`, 1]);\n  return new Map(sortEntries);\n}\n/** @internal */\nfunction objectToMap(t) {\n  const sortEntries = Object.entries(t).map(_ref2 => {\n    let [k, v] = _ref2;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\nfunction mapToMap(t) {\n  const sortEntries = Array.from(t).map(_ref3 => {\n    let [k, v] = _ref3;\n    return [`${k}`, prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** converts a Sort type into a type that is valid for the server (SortForCmd) */\nfunction formatSort(sort, direction) {\n  if (sort == null) return undefined;\n  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]); // 'fieldName'\n  if (typeof sort !== 'object') {\n    throw new error_1.MongoInvalidArgumentError(`Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`);\n  }\n  if (!isReadonlyArray(sort)) {\n    if (isMap(sort)) return mapToMap(sort); // Map<fieldName, SortDirection>\n    if (Object.keys(sort).length) return objectToMap(sort); // { [fieldName: string]: SortDirection }\n    return undefined;\n  }\n  if (!sort.length) return undefined;\n  if (isDeep(sort)) return deepToMap(sort); // [ [fieldName, sortDir], [fieldName, sortDir] ... ]\n  if (isPair(sort)) return pairToMap(sort); // [ fieldName, sortDir ]\n  return stringsToMap(sort); // [ fieldName, fieldName ]\n}","map":{"version":3,"names":["exports","formatSort","error_1","require","prepareDirection","direction","arguments","length","undefined","value","toLowerCase","isMeta","MongoInvalidArgumentError","JSON","stringify","t","$meta","isPair","Array","isArray","isDeep","isMap","Map","size","isReadonlyArray","pairToMap","v","deepToMap","sortEntries","map","_ref","k","stringsToMap","key","objectToMap","Object","entries","_ref2","mapToMap","from","_ref3","sort","keys"],"sources":["C:\\Users\\asmee\\Documents\\Visa-Application\\node_modules\\mongodb\\src\\sort.ts"],"sourcesContent":["import { MongoInvalidArgumentError } from './error';\n\n/** @public */\nexport type SortDirection =\n  | 1\n  | -1\n  | 'asc'\n  | 'desc'\n  | 'ascending'\n  | 'descending'\n  | { readonly $meta: string };\n\n/** @public */\nexport type Sort =\n  | string\n  | Exclude<SortDirection, { readonly $meta: string }>\n  | ReadonlyArray<string>\n  | { readonly [key: string]: SortDirection }\n  | ReadonlyMap<string, SortDirection>\n  | ReadonlyArray<readonly [string, SortDirection]>\n  | readonly [string, SortDirection];\n\n/** Below stricter types were created for sort that correspond with type that the cmd takes  */\n\n/** @public */\nexport type SortDirectionForCmd = 1 | -1 | { $meta: string };\n\n/** @public */\nexport type SortForCmd = Map<string, SortDirectionForCmd>;\n\n/** @internal */\ntype SortPairForCmd = [string, SortDirectionForCmd];\n\n/** @internal */\nfunction prepareDirection(direction: any = 1): SortDirectionForCmd {\n  const value = `${direction}`.toLowerCase();\n  if (isMeta(direction)) return direction;\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new MongoInvalidArgumentError(`Invalid sort direction: ${JSON.stringify(direction)}`);\n  }\n}\n\n/** @internal */\nfunction isMeta(t: SortDirection): t is { $meta: string } {\n  return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';\n}\n\n/** @internal */\nfunction isPair(t: Sort): t is readonly [string, SortDirection] {\n  if (Array.isArray(t) && t.length === 2) {\n    try {\n      prepareDirection(t[1]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  return false;\n}\n\nfunction isDeep(t: Sort): t is ReadonlyArray<readonly [string, SortDirection]> {\n  return Array.isArray(t) && Array.isArray(t[0]);\n}\n\nfunction isMap(t: Sort): t is ReadonlyMap<string, SortDirection> {\n  return t instanceof Map && t.size > 0;\n}\n\nfunction isReadonlyArray<T>(value: any): value is readonly T[] {\n  return Array.isArray(value);\n}\n\n/** @internal */\nfunction pairToMap(v: readonly [string, SortDirection]): SortForCmd {\n  return new Map([[`${v[0]}`, prepareDirection([v[1]])]]);\n}\n\n/** @internal */\nfunction deepToMap(t: ReadonlyArray<readonly [string, SortDirection]>): SortForCmd {\n  const sortEntries: SortPairForCmd[] = t.map(([k, v]) => [`${k}`, prepareDirection(v)]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction stringsToMap(t: ReadonlyArray<string>): SortForCmd {\n  const sortEntries: SortPairForCmd[] = t.map(key => [`${key}`, 1]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction objectToMap(t: { readonly [key: string]: SortDirection }): SortForCmd {\n  const sortEntries: SortPairForCmd[] = Object.entries(t).map(([k, v]) => [\n    `${k}`,\n    prepareDirection(v)\n  ]);\n  return new Map(sortEntries);\n}\n\n/** @internal */\nfunction mapToMap(t: ReadonlyMap<string, SortDirection>): SortForCmd {\n  const sortEntries: SortPairForCmd[] = Array.from(t).map(([k, v]) => [\n    `${k}`,\n    prepareDirection(v)\n  ]);\n  return new Map(sortEntries);\n}\n\n/** converts a Sort type into a type that is valid for the server (SortForCmd) */\nexport function formatSort(\n  sort: Sort | undefined,\n  direction?: SortDirection\n): SortForCmd | undefined {\n  if (sort == null) return undefined;\n\n  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]); // 'fieldName'\n\n  if (typeof sort !== 'object') {\n    throw new MongoInvalidArgumentError(\n      `Invalid sort format: ${JSON.stringify(sort)} Sort must be a valid object`\n    );\n  }\n\n  if (!isReadonlyArray(sort)) {\n    if (isMap(sort)) return mapToMap(sort); // Map<fieldName, SortDirection>\n    if (Object.keys(sort).length) return objectToMap(sort); // { [fieldName: string]: SortDirection }\n    return undefined;\n  }\n  if (!sort.length) return undefined;\n  if (isDeep(sort)) return deepToMap(sort); // [ [fieldName, sortDir], [fieldName, sortDir] ... ]\n  if (isPair(sort)) return pairToMap(sort); // [ fieldName, sortDir ]\n  return stringsToMap(sort); // [ fieldName, fieldName ]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}