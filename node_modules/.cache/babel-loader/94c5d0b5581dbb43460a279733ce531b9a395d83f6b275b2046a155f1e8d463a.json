{"ast":null,"code":"\"use strict\";\n\nconst punycode = require(\"punycode/\");\nconst regexes = require(\"./lib/regexes.js\");\nconst mappingTable = require(\"./lib/mappingTable.json\");\nconst {\n  STATUS_MAPPING\n} = require(\"./lib/statusMapping.js\");\nfunction containsNonASCII(str) {\n  return /[^\\x00-\\x7F]/u.test(str);\n}\nfunction findStatus(val) {\n  let start = 0;\n  let end = mappingTable.length - 1;\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n    const target = mappingTable[mid];\n    const min = Array.isArray(target[0]) ? target[0][0] : target[0];\n    const max = Array.isArray(target[0]) ? target[0][1] : target[0];\n    if (min <= val && max >= val) {\n      return target.slice(1);\n    } else if (min > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n  return null;\n}\nfunction mapChars(domainName, _ref) {\n  let {\n    transitionalProcessing\n  } = _ref;\n  let processed = \"\";\n  for (const ch of domainName) {\n    const [status, mapping] = findStatus(ch.codePointAt(0));\n    switch (status) {\n      case STATUS_MAPPING.disallowed:\n        processed += ch;\n        break;\n      case STATUS_MAPPING.ignored:\n        break;\n      case STATUS_MAPPING.mapped:\n        if (transitionalProcessing && ch === \"ẞ\") {\n          processed += \"ss\";\n        } else {\n          processed += mapping;\n        }\n        break;\n      case STATUS_MAPPING.deviation:\n        if (transitionalProcessing) {\n          processed += mapping;\n        } else {\n          processed += ch;\n        }\n        break;\n      case STATUS_MAPPING.valid:\n        processed += ch;\n        break;\n    }\n  }\n  return processed;\n}\nfunction validateLabel(label, _ref2) {\n  let {\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    transitionalProcessing,\n    useSTD3ASCIIRules,\n    isBidi\n  } = _ref2;\n  // \"must be satisfied for a non-empty label\"\n  if (label.length === 0) {\n    return true;\n  }\n\n  // \"1. The label must be in Unicode Normalization Form NFC.\"\n  if (label.normalize(\"NFC\") !== label) {\n    return false;\n  }\n  const codePoints = Array.from(label);\n\n  // \"2. If CheckHyphens, the label must not contain a U+002D HYPHEN-MINUS character in both the\n  // third and fourth positions.\"\n  //\n  // \"3. If CheckHyphens, the label must neither begin nor end with a U+002D HYPHEN-MINUS character.\"\n  if (checkHyphens) {\n    if (codePoints[2] === \"-\" && codePoints[3] === \"-\" || label.startsWith(\"-\") || label.endsWith(\"-\")) {\n      return false;\n    }\n  }\n\n  // \"4. If not CheckHyphens, the label must not begin with “xn--”.\"\n  if (!checkHyphens) {\n    if (label.startsWith(\"xn--\")) {\n      return false;\n    }\n  }\n\n  // \"5. The label must not contain a U+002E ( . ) FULL STOP.\"\n  if (label.includes(\".\")) {\n    return false;\n  }\n\n  // \"6. The label must not begin with a combining mark, that is: General_Category=Mark.\"\n  if (regexes.combiningMarks.test(codePoints[0])) {\n    return false;\n  }\n\n  // \"7. Each code point in the label must only have certain Status values according to Section 5\"\n  for (const ch of codePoints) {\n    const codePoint = ch.codePointAt(0);\n    const [status] = findStatus(codePoint);\n    if (transitionalProcessing) {\n      // \"For Transitional Processing (deprecated), each value must be valid.\"\n      if (status !== STATUS_MAPPING.valid) {\n        return false;\n      }\n    } else if (status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {\n      // \"For Nontransitional Processing, each value must be either valid or deviation.\"\n      return false;\n    }\n    // \"In addition, if UseSTD3ASCIIRules=true and the code point is an ASCII code point (U+0000..U+007F), then it must\n    // be a lowercase letter (a-z), a digit (0-9), or a hyphen-minus (U+002D). (Note: This excludes uppercase ASCII\n    // A-Z which are mapped in UTS #46 and disallowed in IDNA2008.)\"\n    if (useSTD3ASCIIRules && codePoint <= 0x7F) {\n      if (!/^(?:[a-z]|[0-9]|-)$/u.test(ch)) {\n        return false;\n      }\n    }\n  }\n\n  // \"8. If CheckJoiners, the label must satisify the ContextJ rules\"\n  // https://tools.ietf.org/html/rfc5892#appendix-A\n  if (checkJoiners) {\n    let last = 0;\n    for (const [i, ch] of codePoints.entries()) {\n      if (ch === \"\\u200C\" || ch === \"\\u200D\") {\n        if (i > 0) {\n          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\n            continue;\n          }\n          if (ch === \"\\u200C\") {\n            // TODO: make this more efficient\n            const next = codePoints.indexOf(\"\\u200C\", i + 1);\n            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\n            if (regexes.validZWNJ.test(test.join(\"\"))) {\n              last = i + 1;\n              continue;\n            }\n          }\n        }\n        return false;\n      }\n    }\n  }\n\n  // \"9. If CheckBidi, and if the domain name is a Bidi domain name, then the label must satisfy...\"\n  // https://tools.ietf.org/html/rfc5893#section-2\n  if (checkBidi && isBidi) {\n    let rtl;\n\n    // 1\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\n      rtl = false;\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\n      rtl = true;\n    } else {\n      return false;\n    }\n    if (rtl) {\n      // 2-4\n      if (!regexes.bidiS2.test(label) || !regexes.bidiS3.test(label) || regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label)) {\n        return false;\n      }\n    } else if (!regexes.bidiS5.test(label) || !regexes.bidiS6.test(label)) {\n      // 5-6\n      return false;\n    }\n  }\n  return true;\n}\nfunction isBidiDomain(labels) {\n  const domain = labels.map(label => {\n    if (label.startsWith(\"xn--\")) {\n      try {\n        return punycode.decode(label.substring(4));\n      } catch {\n        return \"\";\n      }\n    }\n    return label;\n  }).join(\".\");\n  return regexes.bidiDomain.test(domain);\n}\nfunction processing(domainName, options) {\n  // 1. Map.\n  let string = mapChars(domainName, options);\n\n  // 2. Normalize.\n  string = string.normalize(\"NFC\");\n\n  // 3. Break.\n  const labels = string.split(\".\");\n  const isBidi = isBidiDomain(labels);\n\n  // 4. Convert/Validate.\n  let error = false;\n  for (const [i, origLabel] of labels.entries()) {\n    let label = origLabel;\n    let transitionalProcessingForThisLabel = options.transitionalProcessing;\n    if (label.startsWith(\"xn--\")) {\n      if (containsNonASCII(label)) {\n        error = true;\n        continue;\n      }\n      try {\n        label = punycode.decode(label.substring(4));\n      } catch {\n        if (!options.ignoreInvalidPunycode) {\n          error = true;\n          continue;\n        }\n      }\n      labels[i] = label;\n      if (label === \"\" || !containsNonASCII(label)) {\n        error = true;\n      }\n      transitionalProcessingForThisLabel = false;\n    }\n\n    // No need to validate if we already know there is an error.\n    if (error) {\n      continue;\n    }\n    const validation = validateLabel(label, {\n      ...options,\n      transitionalProcessing: transitionalProcessingForThisLabel,\n      isBidi\n    });\n    if (!validation) {\n      error = true;\n    }\n  }\n  return {\n    string: labels.join(\".\"),\n    error\n  };\n}\nfunction toASCII(domainName) {\n  let {\n    checkHyphens = false,\n    checkBidi = false,\n    checkJoiners = false,\n    useSTD3ASCIIRules = false,\n    verifyDNSLength = false,\n    transitionalProcessing = false,\n    ignoreInvalidPunycode = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = processing(domainName, {\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules,\n    transitionalProcessing,\n    ignoreInvalidPunycode\n  });\n  let labels = result.string.split(\".\");\n  labels = labels.map(l => {\n    if (containsNonASCII(l)) {\n      try {\n        return `xn--${punycode.encode(l)}`;\n      } catch {\n        result.error = true;\n      }\n    }\n    return l;\n  });\n  if (verifyDNSLength) {\n    const total = labels.join(\".\").length;\n    if (total > 253 || total === 0) {\n      result.error = true;\n    }\n    for (let i = 0; i < labels.length; ++i) {\n      if (labels[i].length > 63 || labels[i].length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n  if (result.error) {\n    return null;\n  }\n  return labels.join(\".\");\n}\nfunction toUnicode(domainName) {\n  let {\n    checkHyphens = false,\n    checkBidi = false,\n    checkJoiners = false,\n    useSTD3ASCIIRules = false,\n    transitionalProcessing = false,\n    ignoreInvalidPunycode = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const result = processing(domainName, {\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules,\n    transitionalProcessing,\n    ignoreInvalidPunycode\n  });\n  return {\n    domain: result.string,\n    error: result.error\n  };\n}\nmodule.exports = {\n  toASCII,\n  toUnicode\n};","map":{"version":3,"names":["punycode","require","regexes","mappingTable","STATUS_MAPPING","containsNonASCII","str","test","findStatus","val","start","end","length","mid","Math","floor","target","min","Array","isArray","max","slice","mapChars","domainName","_ref","transitionalProcessing","processed","ch","status","mapping","codePointAt","disallowed","ignored","mapped","deviation","valid","validateLabel","label","_ref2","checkHyphens","checkBidi","checkJoiners","useSTD3ASCIIRules","isBidi","normalize","codePoints","from","startsWith","endsWith","includes","combiningMarks","codePoint","last","i","entries","combiningClassVirama","next","indexOf","validZWNJ","join","rtl","bidiS1LTR","bidiS1RTL","bidiS2","bidiS3","bidiS4EN","bidiS4AN","bidiS5","bidiS6","isBidiDomain","labels","domain","map","decode","substring","bidiDomain","processing","options","string","split","error","origLabel","transitionalProcessingForThisLabel","ignoreInvalidPunycode","validation","toASCII","verifyDNSLength","arguments","undefined","result","l","encode","total","toUnicode","module","exports"],"sources":["C:/Users/asmee/Documents/Visa-Application/node_modules/mongodb-connection-string-url/node_modules/tr46/index.js"],"sourcesContent":["\"use strict\";\n\nconst punycode = require(\"punycode/\");\nconst regexes = require(\"./lib/regexes.js\");\nconst mappingTable = require(\"./lib/mappingTable.json\");\nconst { STATUS_MAPPING } = require(\"./lib/statusMapping.js\");\n\nfunction containsNonASCII(str) {\n  return /[^\\x00-\\x7F]/u.test(str);\n}\n\nfunction findStatus(val) {\n  let start = 0;\n  let end = mappingTable.length - 1;\n\n  while (start <= end) {\n    const mid = Math.floor((start + end) / 2);\n\n    const target = mappingTable[mid];\n    const min = Array.isArray(target[0]) ? target[0][0] : target[0];\n    const max = Array.isArray(target[0]) ? target[0][1] : target[0];\n\n    if (min <= val && max >= val) {\n      return target.slice(1);\n    } else if (min > val) {\n      end = mid - 1;\n    } else {\n      start = mid + 1;\n    }\n  }\n\n  return null;\n}\n\nfunction mapChars(domainName, { transitionalProcessing }) {\n  let processed = \"\";\n\n  for (const ch of domainName) {\n    const [status, mapping] = findStatus(ch.codePointAt(0));\n\n    switch (status) {\n      case STATUS_MAPPING.disallowed:\n        processed += ch;\n        break;\n      case STATUS_MAPPING.ignored:\n        break;\n      case STATUS_MAPPING.mapped:\n        if (transitionalProcessing && ch === \"ẞ\") {\n          processed += \"ss\";\n        } else {\n          processed += mapping;\n        }\n        break;\n      case STATUS_MAPPING.deviation:\n        if (transitionalProcessing) {\n          processed += mapping;\n        } else {\n          processed += ch;\n        }\n        break;\n      case STATUS_MAPPING.valid:\n        processed += ch;\n        break;\n    }\n  }\n\n  return processed;\n}\n\nfunction validateLabel(label, {\n  checkHyphens,\n  checkBidi,\n  checkJoiners,\n  transitionalProcessing,\n  useSTD3ASCIIRules,\n  isBidi\n}) {\n  // \"must be satisfied for a non-empty label\"\n  if (label.length === 0) {\n    return true;\n  }\n\n  // \"1. The label must be in Unicode Normalization Form NFC.\"\n  if (label.normalize(\"NFC\") !== label) {\n    return false;\n  }\n\n  const codePoints = Array.from(label);\n\n  // \"2. If CheckHyphens, the label must not contain a U+002D HYPHEN-MINUS character in both the\n  // third and fourth positions.\"\n  //\n  // \"3. If CheckHyphens, the label must neither begin nor end with a U+002D HYPHEN-MINUS character.\"\n  if (checkHyphens) {\n    if ((codePoints[2] === \"-\" && codePoints[3] === \"-\") ||\n        (label.startsWith(\"-\") || label.endsWith(\"-\"))) {\n      return false;\n    }\n  }\n\n  // \"4. If not CheckHyphens, the label must not begin with “xn--”.\"\n  if (!checkHyphens) {\n    if (label.startsWith(\"xn--\")) {\n      return false;\n    }\n  }\n\n  // \"5. The label must not contain a U+002E ( . ) FULL STOP.\"\n  if (label.includes(\".\")) {\n    return false;\n  }\n\n  // \"6. The label must not begin with a combining mark, that is: General_Category=Mark.\"\n  if (regexes.combiningMarks.test(codePoints[0])) {\n    return false;\n  }\n\n  // \"7. Each code point in the label must only have certain Status values according to Section 5\"\n  for (const ch of codePoints) {\n    const codePoint = ch.codePointAt(0);\n    const [status] = findStatus(codePoint);\n    if (transitionalProcessing) {\n      // \"For Transitional Processing (deprecated), each value must be valid.\"\n      if (status !== STATUS_MAPPING.valid) {\n        return false;\n      }\n    } else if (status !== STATUS_MAPPING.valid && status !== STATUS_MAPPING.deviation) {\n      // \"For Nontransitional Processing, each value must be either valid or deviation.\"\n      return false;\n    }\n    // \"In addition, if UseSTD3ASCIIRules=true and the code point is an ASCII code point (U+0000..U+007F), then it must\n    // be a lowercase letter (a-z), a digit (0-9), or a hyphen-minus (U+002D). (Note: This excludes uppercase ASCII\n    // A-Z which are mapped in UTS #46 and disallowed in IDNA2008.)\"\n    if (useSTD3ASCIIRules && codePoint <= 0x7F) {\n      if (!/^(?:[a-z]|[0-9]|-)$/u.test(ch)) {\n        return false;\n      }\n    }\n  }\n\n  // \"8. If CheckJoiners, the label must satisify the ContextJ rules\"\n  // https://tools.ietf.org/html/rfc5892#appendix-A\n  if (checkJoiners) {\n    let last = 0;\n    for (const [i, ch] of codePoints.entries()) {\n      if (ch === \"\\u200C\" || ch === \"\\u200D\") {\n        if (i > 0) {\n          if (regexes.combiningClassVirama.test(codePoints[i - 1])) {\n            continue;\n          }\n          if (ch === \"\\u200C\") {\n            // TODO: make this more efficient\n            const next = codePoints.indexOf(\"\\u200C\", i + 1);\n            const test = next < 0 ? codePoints.slice(last) : codePoints.slice(last, next);\n            if (regexes.validZWNJ.test(test.join(\"\"))) {\n              last = i + 1;\n              continue;\n            }\n          }\n        }\n        return false;\n      }\n    }\n  }\n\n  // \"9. If CheckBidi, and if the domain name is a Bidi domain name, then the label must satisfy...\"\n  // https://tools.ietf.org/html/rfc5893#section-2\n  if (checkBidi && isBidi) {\n    let rtl;\n\n    // 1\n    if (regexes.bidiS1LTR.test(codePoints[0])) {\n      rtl = false;\n    } else if (regexes.bidiS1RTL.test(codePoints[0])) {\n      rtl = true;\n    } else {\n      return false;\n    }\n\n    if (rtl) {\n      // 2-4\n      if (!regexes.bidiS2.test(label) ||\n          !regexes.bidiS3.test(label) ||\n          (regexes.bidiS4EN.test(label) && regexes.bidiS4AN.test(label))) {\n        return false;\n      }\n    } else if (!regexes.bidiS5.test(label) ||\n               !regexes.bidiS6.test(label)) { // 5-6\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isBidiDomain(labels) {\n  const domain = labels.map(label => {\n    if (label.startsWith(\"xn--\")) {\n      try {\n        return punycode.decode(label.substring(4));\n      } catch {\n        return \"\";\n      }\n    }\n    return label;\n  }).join(\".\");\n  return regexes.bidiDomain.test(domain);\n}\n\nfunction processing(domainName, options) {\n  // 1. Map.\n  let string = mapChars(domainName, options);\n\n  // 2. Normalize.\n  string = string.normalize(\"NFC\");\n\n  // 3. Break.\n  const labels = string.split(\".\");\n  const isBidi = isBidiDomain(labels);\n\n  // 4. Convert/Validate.\n  let error = false;\n  for (const [i, origLabel] of labels.entries()) {\n    let label = origLabel;\n    let transitionalProcessingForThisLabel = options.transitionalProcessing;\n    if (label.startsWith(\"xn--\")) {\n      if (containsNonASCII(label)) {\n        error = true;\n        continue;\n      }\n\n      try {\n        label = punycode.decode(label.substring(4));\n      } catch {\n        if (!options.ignoreInvalidPunycode) {\n          error = true;\n          continue;\n        }\n      }\n      labels[i] = label;\n\n      if (label === \"\" || !containsNonASCII(label)) {\n        error = true;\n      }\n\n      transitionalProcessingForThisLabel = false;\n    }\n\n    // No need to validate if we already know there is an error.\n    if (error) {\n      continue;\n    }\n    const validation = validateLabel(label, {\n      ...options,\n      transitionalProcessing: transitionalProcessingForThisLabel,\n      isBidi\n    });\n    if (!validation) {\n      error = true;\n    }\n  }\n\n  return {\n    string: labels.join(\".\"),\n    error\n  };\n}\n\nfunction toASCII(domainName, {\n  checkHyphens = false,\n  checkBidi = false,\n  checkJoiners = false,\n  useSTD3ASCIIRules = false,\n  verifyDNSLength = false,\n  transitionalProcessing = false,\n  ignoreInvalidPunycode = false\n} = {}) {\n  const result = processing(domainName, {\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules,\n    transitionalProcessing,\n    ignoreInvalidPunycode\n  });\n  let labels = result.string.split(\".\");\n  labels = labels.map(l => {\n    if (containsNonASCII(l)) {\n      try {\n        return `xn--${punycode.encode(l)}`;\n      } catch {\n        result.error = true;\n      }\n    }\n    return l;\n  });\n\n  if (verifyDNSLength) {\n    const total = labels.join(\".\").length;\n    if (total > 253 || total === 0) {\n      result.error = true;\n    }\n\n    for (let i = 0; i < labels.length; ++i) {\n      if (labels[i].length > 63 || labels[i].length === 0) {\n        result.error = true;\n        break;\n      }\n    }\n  }\n\n  if (result.error) {\n    return null;\n  }\n  return labels.join(\".\");\n}\n\nfunction toUnicode(domainName, {\n  checkHyphens = false,\n  checkBidi = false,\n  checkJoiners = false,\n  useSTD3ASCIIRules = false,\n  transitionalProcessing = false,\n  ignoreInvalidPunycode = false\n} = {}) {\n  const result = processing(domainName, {\n    checkHyphens,\n    checkBidi,\n    checkJoiners,\n    useSTD3ASCIIRules,\n    transitionalProcessing,\n    ignoreInvalidPunycode\n  });\n\n  return {\n    domain: result.string,\n    error: result.error\n  };\n}\n\nmodule.exports = {\n  toASCII,\n  toUnicode\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}